// Generated by CoffeeScript 1.12.6
var fs, has, htmlEntities, remove, sbserv, sha256, ucLoop,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

sha256 = require('sha.js')('sha256');

has = function(arr, item) {
  var a, j, len;
  for (j = 0, len = arr.length; j < len; j++) {
    a = arr[j];
    if (a === item) {
      return true;
    }
  }
  return false;
};

remove = function(arr, item) {
  var i;
  i = 0;
  if (has(arr, item)) {
    arr = arr.splice(arr.indexOf(item), 1);
    if (has(arr, item)) {
      return remove(arr, item);
    }
  }
  return arr;
};

sbserv = {};

sbserv.ips = {};

sbserv.pendingData = {};

sbserv.lastGet = {};

sbserv.users = [];

sbserv.log = [];

sbserv.admins = [];

sbserv.bans = [];

sbserv.adminKey = sha256.update(fs.readFileSync("adminpass.txt"), "utf8").digest("hex");

htmlEntities = function(str) {
  return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
};

sbserv.checkAdmin = function(ip) {
  var a, j, len, ref;
  ref = sbserv.admins;
  for (j = 0, len = ref.length; j < len; j++) {
    a = ref[j];
    if (a === ip) {
      return true;
    }
  }
  return false;
};

sbserv.newUser = function(ip, nick) {
  var b, j, l, len, len1, n, ref, ref1, x;
  ref = sbserv.users;
  for (j = 0, len = ref.length; j < len; j++) {
    n = ref[j];
    if (nick === n) {
      return 1;
    }
  }
  ref1 = sbserv.bans;
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    b = ref1[l];
    if (b === ip) {
      return 2;
    }
  }
  if (indexOf.call(sbserv.ips, ip) >= 0) {
    disconnect(ip, sbserv.ips[ip], "Killed (old client " + sbserv.ips[ip] + " overlapped with new client " + nick + " for same IP)");
  }
  sbserv.relay({
    text: "--> " + nick + " joined",
    nick: nick,
    highlight: false
  });
  console.log("[CHAT] --> " + nick + " joined");
  sbserv.users.push(nick);
  sbserv.pendingData[nick] = sbserv.log;
  sbserv.pendingData[nick].push({
    text: "=== END OF LOGS ===",
    nick: nick,
    highlight: false
  });
  sbserv.pendingData[nick].push({
    text: "--- Users: " + (sbserv.users.join(" ")),
    nick: nick,
    highlight: false
  });
  sbserv.pendingData[nick].push({
    text: "--- Admins: " + ([
      (function() {
        var len2, m, ref2, results;
        ref2 = sbserv.admins;
        results = [];
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          x = ref2[m];
          results.push(sbserv.ips[x]);
        }
        return results;
      })()
    ].join(" ")),
    nick: nick,
    highlight: false
  });
  sbserv.lastGet[nick] = +new Date();
  sbserv.ips[ip] = nick;
  sbserv.relay();
  return 0;
};

sbserv.disconnect = function(ip, nick, reason) {
  var k, v;
  if (sbserv.ips[ip] !== nick) {
    return;
  }
  if (reason == null) {
    reason = "";
  }
  if (reason != null) {
    reason = " (" + reason + ")";
  }
  console.log("[CHAT] <-- " + nick + " left" + reason);
  sbserv.relay({
    text: "<-- " + nick + " left" + reason,
    nick: nick,
    highlight: false
  });
  delete sbserv.pendingData[nick];
  if ((function() {
    var ref, results;
    ref = sbserv.ips;
    results = [];
    for (k in ref) {
      v = ref[k];
      results.push(v === nick);
    }
    return results;
  })()) {
    delete sbserv.ips[k];
  }
  delete sbserv.lastGet[nick];
  return sbserv.users = remove(sbserv.users, nick);
};

sbserv.relay = function(text) {
  var j, k, len, ref;
  if (text == null) {
    return;
  }
  text.text = htmlEntities(text.text);
  sbserv.log.push(text);
  ref = Object.keys(sbserv.pendingData);
  for (j = 0, len = ref.length; j < len; j++) {
    k = ref[j];
    sbserv.pendingData[k].push(text);
  }
};

sbserv.serveAjax = function(ip, addr, data) {
  var a, ips, j, k, ks, l, len, len1, logs, n, nick, other, ref, ref1, ref2, ref3, succ, v, x;
  if (addr === "sendchat") {
    if (data.text === "") {
      return {};
    }
    console.log("[CHAT] <" + sbserv.ips[ip] + "> " + data.text);
    sbserv.relay({
      text: "<" + sbserv.ips[ip] + "> " + data.text,
      nick: sbserv.ips[ip],
      highlight: true
    });
    return {};
  } else if (addr === "getchat") {
    if ((!has(sbserv.ips, ip)) || has(sbserv.bans, ip)) {
      ({
        "continue": false,
        logs: [],
        next: 5000
      });
    }
    sbserv.lastGet[sbserv.ips[ip]] = +new Date();
    logs = sbserv.pendingData[sbserv.ips[ip]];
    sbserv.pendingData[sbserv.ips[ip]] = [];
    return {
      logs: logs,
      next: 0.5,
      "continue": true
    };
  } else if (addr === "setnick") {
    ref = sbserv.users;
    for (j = 0, len = ref.length; j < len; j++) {
      n = ref[j];
      if (data.newNick === n) {
        return {
          "continue": false
        };
      }
    }
    nick = sbserv.ips[ip];
    sbserv.ips[ip] = data.newNick;
    sbserv.pendingData[data.newNick] = sbserv.pendingData[nick];
    delete sbserv.lastGet[nick];
    delete sbserv.pendingData[nick];
    sbserv.users = remove(sbserv.users, nick);
    sbserv.users.push(data.newNick);
    sbserv.relay({
      text: "*-* " + nick + " changed his nickname to " + data.newNick,
      nick: data.newNick,
      highlight: false
    });
    return {
      "continue": true
    };
  } else if (addr === "adminauth") {
    console.log(data.password + " : " + sbserv.adminKey);
    if (data.password === sbserv.adminKey) {
      sbserv.admins.push(ip);
      sbserv.relay({
        text: "+++ " + sbserv.ips[ip] + " elevated to admin",
        nick: sbserv.ips[ip],
        highlight: false
      });
      return {
        success: true
      };
    } else {
      return {
        success: false
      };
    }
  } else if (addr === "kick") {
    if (!sbserv.checkAdmin(ip)) {
      return {
        success: false
      };
    }
    succ = false;
    ks = [];
    ref1 = sbserv.ips;
    for (k in ref1) {
      v = ref1[k];
      if (v === data.other) {
        sbserv.relay({
          text: "+++ " + sbserv.ips[ip] + " kicked " + v,
          nick: sbserv.ips[ip],
          highlight: false
        });
        ks.push([k, v]);
        succ = true;
      }
    }
    for (l = 0, len1 = ks.length; l < len1; l++) {
      a = ks[l];
      sbserv.disconnect(a[0], a[1], "Kicked by " + sbserv.ips[ip]);
    }
    return {
      success: succ
    };
  } else if (addr === "kickban") {
    if (!sbserv.checkAdmin(ip)) {
      return {
        success: false
      };
    }
    succ = false;
    ref2 = sbserv.ips;
    for (k in ref2) {
      v = ref2[k];
      if (k === data.banIP) {
        other = v;
        sbserv.relay({
          text: "+++ " + sbserv.ips[ip] + " kickbanned " + v,
          nick: sbserv.ips[ip],
          highlight: false
        });
        sbserv.disconnect(k, v, "Kickbanned by " + sbserv.ips[ip]);
        succ = true;
      }
    }
    sbserv.bans.push(data.banIP);
    return {
      success: succ
    };
  } else if (addr === "unban") {
    if (!sbserv.checkAdmin(ip)) {
      return {
        success: false
      };
    }
    sbserv.bans = remove(sbserv.bans, data.banIP);
    sbserv.relay({
      text: "+++ " + sbserv.ips[ip] + " unbanned " + data.banIP,
      nick: sbserv.ips[ip],
      highlight: false
    });
    return {
      success: true
    };
  } else if (addr === "getips") {
    if (!sbserv.checkAdmin(ip)) {
      return {
        success: false,
        ips: []
      };
    }
    ips = [];
    ref3 = sbserv.ips;
    for (k in ref3) {
      v = ref3[k];
      if (v === data.other) {
        ips.push(k);
      }
    }
    return {
      success: true,
      ips: ips
    };
  } else if (addr === "userlist") {
    return {
      users: sbserv.users,
      admins: [
        (function() {
          var len2, m, ref4, results;
          ref4 = sbserv.admins;
          results = [];
          for (m = 0, len2 = ref4.length; m < len2; m++) {
            x = ref4[m];
            results.push(sbserv.ips[x]);
          }
          return results;
        })()
      ]
    };
  }
};

sbserv.findip = function(nick) {
  var k, ref, v;
  ref = sbserv.ips;
  for (k in ref) {
    v = ref[k];
    if (v === nick) {
      return k;
    }
  }
};

ucLoop = function() {
  var k, ref, results, v;
  ref = sbserv.lastGet;
  results = [];
  for (k in ref) {
    v = ref[k];
    if (+new Date() - v > 30000) {
      results.push(sbserv.disconnect(sbserv.findip(k), k));
    } else {
      results.push(void 0);
    }
  }
  return results;
};

setInterval(ucLoop, 2000);

module.exports = {
  sbserv: sbserv
};
